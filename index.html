<!DOCTYPE html>
<html>
  <head>
    <title>TPR: Lab 1</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="robots" content="noindex, nofollow">
    <style type="text/css">
         @import url(http://fonts.googleapis.com/css?family=Voces&subset=latin,latin-ext);

         body {
           font-family: 'Voces';
           font-size: 20px;
         }
         h1, h2, h3 {
           font-family: 'Voces';
           font-weight: 400;
           margin-bottom: 0;
         }
         h1 { font-size: 3em; line-height: 1.2em; }
         h2 { font-size: 2em; }
         h3 { font-size: 1.6em; }
         .footnote {
           position: absolute;
           bottom: 3em;
         }
         li { line-height: 1.4em; }
         .red { color: #fa0000; }
         .large { font-size: 2em; }
         a, a > code {
           color: rgb(249, 38, 114);
           text-decoration: none;
         }
         code {
           -moz-border-radius: 5px;
           -web-border-radius: 5px;
           background: #e7e8e2;
           border-radius: 5px;
           font-size: 16px;
         }
         .pull-left {
           float: left;
           width: 47%;
         }
         .pull-right {
           float: right;
           width: 47%;
         }
         .pull-right ~ p {
           clear: both;
         }
         #slideshow .slide .content code {
           font-size: 0.8em;
         }
         #slideshow .slide .content pre code {
           font-size: 0.9em;
           padding: 15px;
         }
         .inverse {
           background: #272822;
           color: #777872;
           text-shadow: 0 0 20px #333;
         }
         .inverse h1, .inverse h2 {
           color: #f3f3f3;
           line-height: 0.8em;
         }

         /* Slide-specific styling */
         #slide-inverse .footnote {
           bottom: 12px;
           left: 20px;
         }
         #slide-how .slides {
           font-size: 0.9em;
           position: absolute;
           top:  151px;
           right: 140px;
         }
         #slide-how .slides h3 {
           margin-top: 0.2em;
         }
         #slide-how .slides .first, #slide-how .slides .second {
           padding: 1px 20px;
           height: 90px;
           width: 120px;
           -moz-box-shadow: 0 0 10px #777;
           -webkit-box-shadow: 0 0 10px #777;
           box-shadow: 0 0 10px #777;
         }
         #slide-how .slides .first {
           background: #fff;
           position: absolute;
           top: 20%;
           left: 20%;
           z-index: 1;
         }
         #slide-how .slides .second {
           position: relative;
           background: #fff;
           z-index: 0;
         }

         /* Two-column layout */
         .left-column {
           color: #777;
           width: 20%;
           height: 92%;
           float: left;
         }
           .left-column h2:last-of-type, .left-column h3:last-child {
             color: #000;
           }
         .right-column {
           width: 75%;
           float: right;
           padding-top: 2em;
         }
       </style>
  </head>
  <body><textarea id="source">
class: center, middle, inverse

# Techniki Programowania Równoległego

## http://kfigiela.github.io/mpi_lab

---

class: middle
## ![Avatar](http://olorin.info/av/av120.jpg) mgr inż. Kamil Figiela

.right-column[

* 1 i 3 zajęcia 
* Preferowany kontakt mailowy [kfigiela@agh.edu.pl](mailto:kfigiela@agh.edu.pl)
* Można mnie spoktać na forum
* Pokój 3.42
]

---
class: middle
# Organizacja zajęć

Wykład prowadzą:

* dr inż. Renata Słota (~10, ocena
końcowa)
* dr inż. Witold Alda (5)

Zajęcia laboratoryjne prowadzą:

* Cz.1 (blokowo)
  * dr inż. Renata Słota (1 zajęcia),
  * dr inż. Włodzimierz Funika (1 zajęcia),
  * mgr inż. Kamil Figiela (2 zajęcia),
  * mgr inż. Dariusz Król (3 zajęcia),
  * mgr inż. Michał Orzechowski (2 zajęcia).
* Cz.2 (grupy)
  * dr inż. Witold Alda (6 grup)
  * mgr inż. Dariusz Król (3 grupy)

---
class: middle
# Organizacja zajęć

* Wykład (egzamin):
  * egzamin zerowy ustny (~16–18 czerwca);
  * dopuszczenie do egz. zerowego przy zal. 5.0 z labów;
  * terminy kolejne = test.
* Laboratorium (2/3 PR; 1/3 PR na GPU).
* Ocena końcowa: średnia z egz. i zal. z lab, ze wskazaniem na laby.


---
class: middle
# Tematyka części 1 (9 zajęć)

* Interfejs MPI
  * Podstawowe badania dotyczące opóźnienia i przepustowości - komunikacja typu punkt–punkt (spr. 1)
  * Komunikacja grupowa (spr. 2) 
  * Algorytm równoległy I (spr. 3)
  * Równoległość idealna + Badanie efektywności algorytmu
  * Typy pochodne
  * Algorytm równoległy II (spr. 4)
  * Mnożenie macierzy + Badanie efektywności algorytmu
* MapReduce
* OpenMP (spr. 5) 
* Scalarm

---
class: middle

# Zasady oceniania części 1

* Punktacja pierwszych 9 spotkań (waga 2/3 do oceny z labów):
  * 9 ćwiczeń laboratoryjnych, na każdych do zdobycia:
    * 3 punkty za zadania z zajęć,
    * 2 punkty za aktywność;
  * 5 sprawozdań z zadań domowych, każde warte 9 punktów.
* Wszystkie sprawozdania są obowiązkowe.
* Łącznie można zdobyć 90 punktów.
* Oceny wyliczane zgodnie z regulaminem studiów, za 100% przyjmujemy 80 punktów, ze względu na uznaniowość aktywności.
* Zasady oceniania części 2 (zajęć z GPU) przedstawi dr Alda.

---
class: middle

# Moodle

* Kurs: Techniki programowania równoległego
* http://upel.agh.edu.pl/wiet/course/view.php?id=3
* Klucz do kursu: `TPR2014`

---
class: center, middle

# Konta na serwerze gandalf.icsr.agh.edu.pl

## Czy jest ktoś bez konta?

---
class: middle

# Konta na serwerach Cyfronetu/PLGrid/Zeus

1. http://plgrid.pl › Rejestracja
2. Należy podać:
  * Typ: Użytkownik
  * Opiekun: Renata Słota
  * Nr OPI opiekuna: 93749
  * Nasz typ OPI: podopieczny
  * Temat badań: AGH. Techniki Programowania Równoległego
3. Po aktywacji konta na http://portal.plgrid.pl/ należy aktywować:
  * Dostęp do UI - Cyfronet
  * Dostęp do klastra ZEUS
3. `ssh login@ui.cyfronet.pl`
4. HowTo: https://docs.cyfronet.pl/display/PLGDoc/Dokumentacja+PL-Grid

---
class: center, middle

# Techniki Programowania Równoległego

---
class: middle

# Plan na dziś

1. Uruchomienie Hello World!
  * Python
  * C
  * C++ i Boost
2. Prosta komunikacja w MPI
3. Pomiar czasu dla ping-pong
4. Aplikacje typu master-slave
5. Zadanie domowe


---
class: middle

# Środowisko

* `ssh vnode-01.dydaktyka.icsr.agh.edu.pl`
* Klaster dostępny m.in. z serwera `gandalf.icsr.agh.edu.pl`
* Credentiale takie same jak na gandalfie
* SSH z gandalfa nie wymaga podawania hasła
* `$HOME` jest współdzielony z gandalfem (NFS)
* Większe operacje IO lepiej wykonywać w lokalnym `/tmp`
* Klaster jest zwirtualizowany
  * 3 maszyny x 4 CPU (nody 01, 02, 03)
  * 12 maszyn x 1 CPU (nody od 04 do 15)


---
class: middle
## Krótki tutorial po MPI

### Konfiguracja

* Przykłady: `git clone https://github.com/kfigiela/mpi_p2p_lab.git`
* Tworzymy plik `mpihosts`
* Ustawiamy środowisko (np. w `~/.bash_profile`) – `source profile.sh`:
```
export PYTHONPATH=/usr/lib64/python2.6/site-packages/mpich2
```
* Dla zainteresowanych - dostępne są dwie implementacje MPI: OpenMPI i MPICH2 (domyślna)
  * OpenMPI można załadować za pomocą polecenia
    ```
    $ module load openmpi-x86_64
    ```
  * Trzeba wtedy zmienić w/w zmienną środowiskową
  
---
## Hello world! w Pythonie

Dokumentacja mpi4py: http://mpi4py.scipy.org/docs/usrman/index.html

```python
#!/usr/bin/python
from mpi4py import MPI
import socket

comm = MPI.COMM_WORLD
print("hello world")
print("my rank is: %d, at node %s"%(comm.rank, socket.gethostname()))
```
### Uruchomienie
```
$ chmod +x hello_world.py
$ mpiexec -machinefile ~/mpihosts -np [liczba procesów] ./hello_world.py
```


---
## Komunikacja w Pythonie

```python
#!/usr/bin/python
from mpi4py import MPI
comm = MPI.COMM_WORLD
rank = comm.Get_rank()

if rank == 0:
   data = ('abc',123)
   comm.send(data, dest=1)
elif rank == 1:
   data = comm.recv(source=0)
   print data
else:
   print "Expected only two nodes"
```

---
## Hello world! w Fortranie ;-)

```fortran
c  Fortran example  
   program hello
   include 'mpif.h'
   integer rank, size, ierror, tag, status(MPI_STATUS_SIZE)
   
   call MPI_INIT(ierror)
   call MPI_COMM_SIZE(MPI_COMM_WORLD, size, ierror)
   call MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierror)
   print*, 'node', rank, ': Hello world'
   call MPI_FINALIZE(ierror)
   end
```

---
## Hello world! w C

* Dokumentacja i standard: http://www.mcs.anl.gov/research/projects/mpi/
* Tutorial http://mpitutorial.com/ i przykłady https://github.com/wesleykendall/mpitutorial

```cpp
#include <stdio.h>
#include <mpi.h>

int main (int argc, char * argv[])
{
  int rank, size;

  MPI_Init (&argc, &argv);  /* starts MPI */
  MPI_Comm_rank (MPI_COMM_WORLD, &rank);  /* get current process id */
  MPI_Comm_size (MPI_COMM_WORLD, &size);  /* get number of processes */
  printf( "Hello world from process %d of %d\n", rank, size );
  MPI_Finalize();
  return 0;
}


```
### Kompilacja
```shell
$ mpicc hello_world.c
```



---
## Komunikacja w C

```cpp
#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv) {
  MPI_Init(NULL, NULL);
  int world_rank;
  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
  int world_size;
  MPI_Comm_size(MPI_COMM_WORLD, &world_size);

  // We are assuming at least 2 processes for this task
  if (world_size < 2) {
    fprintf(stderr, "World size must be greater than 1 for %s\n", argv[0]);
    MPI_Abort(MPI_COMM_WORLD, 1); 
  }
  int number;
  if (world_rank == 0) {
    // If we are rank 0, set the number to -1 and send it to process 1
    number = -1;
    MPI_Send(&number, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);
  } else if (world_rank == 1) {
    MPI_Recv(&number, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
    printf("Process 1 received number %d from process 0\n", number);
  }
  MPI_Finalize();
}
```

---
## Hello world! w C++ i Boost

Dokumentacja: http://www.boost.org/doc/libs/1_55_0/doc/html/mpi.html

```cpp
#include <boost/mpi/environment.hpp>
#include <boost/mpi/communicator.hpp>
#include <iostream>
namespace mpi = boost::mpi;

int main()
{
  mpi::environment env;
  mpi::communicator world;
  std::cout << "I am process " << world.rank() << " of " << world.size()
            << "." << std::endl;
  return 0;
}

```

### Kompilacja

```shell
$ mpic++ -lboost_mpi hello_world.cpp
```

---
## Komunikacja w C++ i Boost

```cpp
#include <boost/mpi.hpp>
#include <iostream>
#include <string>
#include <boost/serialization/string.hpp>
namespace mpi = boost::mpi;

int main()
{
  mpi::environment env;
  mpi::communicator world;

  if (world.rank() == 0) {
    world.send(1, 0, std::string("Hello world!"));
  } else if(world.rank() == 1) {
    std::string msg;
    world.recv(0, 0, msg);
    std::cout << msg << std::endl;
  }

  return 0;
}
```

---
class: middle

# Ćwiczenie 1
## Sposoby komunikacji

* Przetestuj rózne sposoby komunikacji P2P dostępne w MPI.
* Sposoby komunikacji [1]
  * Standard send `MPI_Send`
  * Synchronous send `MPI_Ssend`
  * Buffered send `MPI_Bsend`
  * Ready send `MPI_Rsend`
  * Non-blocking send `MPI_Isend` + `MPI_Wait`, `MPI_Test`
* Odbieranie danych `MPI_Recv`, `MPI_Irecv`

.footnote[[1] http://www.dartmouth.edu/~rc/classes/intro_mpi/mpi_comm_modes.html]

???

* Złosliwe pytanie: Jak działa komunikacja standardowa?

---
class: middle

# Ćwiczenie 2
## Mierzenie opóźnień

* Zaimplementuj aplikację, gdzie 2 węzły wymieniają się komunikatami (ping–pong).
* Sprawdź zwykłą i buforowaną komunikację.
* Zmierz opóźnienie (przyda się funkcja `MPI_Wtime`). W jaki sposób należy dokonać pomiaru?

---
class: middle

# Ćwiczenie 3
## „Token ring”

* Zaimplementuj aplikację, w której każdy node przesyła do kolejnego otrzymaną daną.
* Sprawdź zwykłą i synchroniczną komunikację.
* Jak poprzednio dokonaj pomiarów.
---
class: middle

# Ćwiczenie 4
## Master–slave w MPI

Dwa podejścia:

 * wszystko w 1 pliku (master dla rank == 0, slave dla pozostałych),
 * uruchamianie innego pliku binarnego (`MPI_Comm_spawn`): http://www.mcs.anl.gov/research/projects/mpi/mpi-standard/mpi-report-2.0/node98.htm

---
class: middle
# Zadanie domowe

Należy przetestować dwa różne typy komunikacji P2P w MPI i narysować wykres przepustowości [Mbit/s] od długości komunikatów [B]. 

* Zespoły 4 osobowe:
  * 3 osoby implementują testy w C/C++/Python,
  * czwarta osoba uruchamia kody pozostałych osób i przeprowadza testy na klastrze Zeus.

### Sugestie

* Do rysowania wykresów można użyć [Gnuplot](http://www.gnuplot.info) lub [R](http://www.r-project.org).
* Upewnijcie się, że macie tą samą metodę testów/pomiarów.

---
class: middle
# Zasady oceniania zadania

* Sprawozdanie stanowią:
  * wykresy,
  * kod programu,
  * wyniki pomiarów,
  * wiedza/komentarz/odpowiedź na pytania.
* Nic nie drukujemy, nie trzeba tworzyć dokumentu sprawozdania, ale warto zrobić notatki z wnioskami.
* Wykresy bez podpisanych osi i bez dodatkowych informacji nie będą przyjmowane
* Punktacja:
  * 2 punkty za poprawny kod i jego znajomość,
  * 2 punkty za poprawne wykresy i ich omówienie,
  * 2 punkty za poprawne wyniki,
  * 3 punkty za odpowiedź na pytania teoretyczne z danego zagadnienia.

---

# Zeus

System modułów – oprogramowanie ładowane do `$PATH` na żądanie

```
[plgkfigiela@zeus ~]$ module avail

---------- /software/local/Modules/versions ----------
3.2.10     3.2.10.el6 3.2.9

--- /software/local/Modules/3.2.10.el6/modulefiles ---
dot         module-info null
module-git  modules

------ /software/local/Modules/modulefiles/el6 -------
apps/arora/0.11.0
apps/autodock/4.2.3
apps/bamtools/2.3.0
.....

[plgkfigiela@zeus ~]$ module load tools/mpich
 'tools/mpich/3.0.4' load complete.
```

---
# Zeus

  * Obsługa systemu kolejkowego (PBS): https://docs.plgrid.pl/pages/viewpage.action?pageId=4260614
  * Tutoriale dla inneych klastrów (przykłady dla MPI):
     * http://kdm.wcss.wroc.pl/wiki/MPIEXEC,
     * http://www.icm.edu.pl/kdm/System_kolejkowy.
  * U nas: `qsub -I -q plgrid -l nodes=2:ppn=12`:
    * `nodes=2` – liczba węzłów,
    * `ppn=12` – liczba rdzeni na każdym węźle.
    * Po zakolejkowaniu zadania otrzymamy interaktywną konsolę.
    * Dalej normalnie – `mpiexec`, liczby procesorów, machinefile nie trzeba podawać.
</textarea>
  <script src="http://gnab.github.io/remark/downloads/remark-0.6.0.min.js" type="text/javascript">
  </script>
  <script type="text/javascript">
    var slideshow = remark.create({highlightStyle: 'monokai'});
  </script>
</body>
</html>